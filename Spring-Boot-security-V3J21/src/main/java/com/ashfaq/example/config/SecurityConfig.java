package com.ashfaq.example.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity//we need to add to enable security
public class SecurityConfig {

	@Autowired
	private CustomUserDetailService userDetailService;

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {

		// 1 CSRF
		httpSecurity.csrf(csrf -> csrf.disable()); // By default, Spring Security enables CSRF protection.

		// when to disable csrf

		// REST APIs: Stateless nature and token-based authentication make CSRF
		// protection unnecessary.
		// Microservices: If the service is purely an API without user-facing forms,
		// CSRF protection can be disabled.

		// when to enable csrf

		// Traditional Web Applications: Applications where users interact with forms
		// should have CSRF protection to prevent unauthorized actions.
		// State-Changing Operations: If your application has state-changing operations
		// performed by logged-in users, CSRF protection is essential.

		// Effects:
		//
		// Token Generation:
		//
		// CSRF Tokens: Spring generates a unique CSRF token for each session. This
		// token must be included in each state-changing request (e.g., POST, PUT,
		// DELETE).
		// Form Integration: Forms generated by Spring automatically include the CSRF
		// token. For non-Spring forms, you must manually include the token.
		// Request Validation:
		//
		// Validation: Spring Security checks for the CSRF token in state-changing
		// requests. If the token is missing or invalid, the request is rejected.
		// Error Handling: If a CSRF token is not included in a request or is invalid,
		// the server responds with a 403 Forbidden status.

		// 2 Requests
		httpSecurity.authorizeHttpRequests((requests) -> {

			requests.requestMatchers("/home").permitAll();
		
//		OR	requests.requestMatchers("/home","/register/user").permitAll(); in a single line we can provide all the api to be permitted to all users
//			or a new requestmathcers can be added as below

			requests.requestMatchers("/register/user").permitAll();
			
			
			
			requests.requestMatchers("/user/**").hasRole("USER");

			requests.requestMatchers("/admin/**").hasRole("ADMIN");

			requests.anyRequest().authenticated();

		});

		// 3 Login methods

		httpSecurity.formLogin(Customizer.withDefaults()); // User-Focused Applications
		// Applications where all interactions are intended to be through a web
		// interface by human users.
		// we can use both form and http basic login but its depending on the usecase
		httpSecurity.httpBasic(Customizer.withDefaults());// API-Only Applications
		// Applications that are purely APIs meant to be consumed by other services or
		// clients where there is no need for a human-readable login form.

		httpSecurity.logout(logout -> logout.permitAll()); // Enable logout functionality

		return httpSecurity.build();
	}

	// in memory USER
//	@Bean
//	public UserDetailsService userDetailsService() {
//		
//		
//		UserDetails normalUser =User.builder()
//				.username("ashfaq")
//				.password(bCryptPasswordEncoder().encode("password"))
//				.roles("USER")
//				.build();
//		
//		UserDetails adminUser = User.builder()
//				.username("adminuser")
//				.password(bCryptPasswordEncoder().encode("password"))
//				.roles("ADMIN","USER")
//				.build();
//		
//		return new InMemoryUserDetailsManager(normalUser,adminUser);
//	}

	// DB USER

	@Bean
	public UserDetailsService userDetailsService() {
		return userDetailService;
	}
	
//	UserDetailsService > needs UserDetails > created by Builder class called User but data is coming from AppUser class, which is ours 
//but if you see we are not configuring UserDetailsService with endcoder so we have to encode the password as well so 
//	we have to create a bean AuthenticationProvider and need to provide the userDetailsService() and need to tell the bean to 
//	encode the password so we have to use bCryptPasswordEncoder()

	@Bean
	public AuthenticationProvider authenticationProvider() {

//		dataaccessobject DAO this is authentication provider for DB 
		DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
		provider.setUserDetailsService(userDetailsService());
		provider.setPasswordEncoder(bCryptPasswordEncoder());
		return provider;
	}

	@Bean
	public PasswordEncoder bCryptPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}

}
